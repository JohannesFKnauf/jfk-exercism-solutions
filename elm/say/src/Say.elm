module Say exposing (SayError(..), say)

import Dict


type SayError
    = Negative
    | TooLarge


type AnnotatedString
    = Word String
    | OptionalAndPrefix
    | OptionalAndSuffix
    | MandatoryAndPrefix
    | MandatoryAndSuffix
    | None


say : Int -> Result SayError String
say number =
    if number == 0 then
        Ok "zero"
    else if number < 0 then
        Err Negative
    else if number > 999999999999 then
        Err TooLarge
    else
        number
            |> chunksOfThousand
            |> List.map2 Tuple.pair magnitudes
            |> List.filter (\( _, chunk ) -> chunk /= 0)
            |> List.map (\( magnitude, chunk ) -> sayChunk magnitude chunk)
            |> List.reverse
            |> List.concat
            |> applyAnds
            |> String.join " "
            |> Ok


-- chunksOfThousand splits a number into chunks of thousand
-- note: it will be in reverse order, starting with the smallest chunk
chunksOfThousand : Int -> List Int
chunksOfThousand n =
    let
        ( rest, chunk ) =
            splitBy 1000 n
    in
    if n > 0 then
        chunk :: chunksOfThousand rest

    else
        []

-- applyAnds expands the "and" concatenations based on a simple rule
-- Simple Word elements are just passed through.
-- Whenever a prefix/suffix pair appears and at least 1 part is mandatory, "and" is expanded. 
applyAnds : List AnnotatedString -> List String
applyAnds xxs =
    let
        applyAnd x y =
            case (x, y) of
                (Word a, _) -> [a]
                (MandatoryAndSuffix, MandatoryAndPrefix) -> ["and"]
                (MandatoryAndSuffix, OptionalAndPrefix) -> ["and"]
                (OptionalAndSuffix, MandatoryAndPrefix) -> ["and"]
                _ -> []
    in
    List.map2 applyAnd xxs (None :: xxs) |> List.concat

-- sayChunk expands a chunk into words and "and" concatenation annotations
sayChunk : String -> Int -> List AnnotatedString
sayChunk magnitude chunk =
    let
        ( hundreds, tens ) =
            splitBy 100 chunk

        hun =
            if hundreds > 0 then
                [ Word (sayTwoDigitNumber hundreds), Word "hundred", MandatoryAndPrefix ]

            else
                []

        min =
            if tens > 0 && magnitude /= "" then
                [ OptionalAndSuffix, Word <| sayTwoDigitNumber tens ]

            else if tens > 0 && magnitude == "" then
                [ MandatoryAndSuffix, Word <| sayTwoDigitNumber tens ]

            else
                []

        mag =
            if magnitude /= "" then
                [ Word magnitude, OptionalAndPrefix ]

            else
                []
    in
    hun ++ min ++ mag

-- sayTwoDigitNumber expands a two-digit number into a word
sayTwoDigitNumber : Int -> String
sayTwoDigitNumber num =
    let
        ( tens, ones ) =
            splitBy 10 num
    in
    if tens == 0 then
        safeGet ones primitiveNumberWords

    else if tens == 1 then
        safeGet (10 + ones) primitiveNumberWords

    else if ones == 0 then
        safeGet (10 * tens) primitiveNumberWords

    else
        safeGet (10 * tens) primitiveNumberWords ++ "-" ++ safeGet ones primitiveNumberWords

-- primitiveNumberWords contains all number word primitives that can not be generated by rules
primitiveNumberWords : Dict.Dict Int String
primitiveNumberWords =
    Dict.fromList
        [ ( 0, "zero" )
        , ( 1, "one" )
        , ( 2, "two" )
        , ( 3, "three" )
        , ( 4, "four" )
        , ( 5, "five" )
        , ( 6, "six" )
        , ( 7, "seven" )
        , ( 8, "eight" )
        , ( 9, "nine" )
        , ( 10, "ten" )
        , ( 11, "eleven" )
        , ( 12, "twelve" )
        , ( 13, "thirteen" )
        , ( 14, "fourteen" )
        , ( 15, "tifteen" )
        , ( 16, "sixteen" )
        , ( 17, "seventeen" )
        , ( 18, "eighteen" )
        , ( 19, "nineteen" )
        , ( 20, "twenty" )
        , ( 30, "thirty" )
        , ( 40, "forty" )
        , ( 50, "fifty" )
        , ( 60, "sixty" )
        , ( 70, "seventy" )
        , ( 80, "eighty" )
        , ( 90, "ninety" )
        ]

-- magnitudes contains all magnitude words
magnitudes : List String
magnitudes =
    [ ""
    , "thousand"
    , "million"
    , "billion"
    ]


-- splitBy is a convenience function to split a number by integral division
splitBy : Int -> Int -> ( Int, Int )
splitBy div num =
    ( num // div, remainderBy div num )

-- safeGet is a convenience function to lookup a key from a dict that is known to exist
safeGet : comparable -> Dict.Dict comparable String -> String
safeGet key dict =
    Dict.get key dict |> Maybe.withDefault ""
